---
alwaysApply: true
---

# Offline-First & Synchronization Architecture

## Purpose
Define queueing and synchronization behavior for degraded or disconnected network conditions.
This file owns offline orchestration rules.

## Offline Ownership
Offline layer owns:
- Connectivity observation
- Mutation queueing and persistence
- Sync orchestration and retry
- Hydration and restart recovery

Offline layer must not:
- Render UI
- Contain domain-specific business rules
- Be driven directly from component render logic

## Core Modules
```txt
src/offline/
  index.js
  queue.js
  sync.manager.js
  network.listener.js
  hydration.js
```

## Queue Rules
- Queue only mutation/intent operations, not read-only requests.
- Preserve queue order and idempotency guarantees.
- Persist queue state across restarts.
- Corrupt entries must fail safely and be isolated.

## Sync Rules
- Sync is event-driven (reconnect, foreground, worker trigger, explicit retry intent).
- Partial failures must not block unrelated queue items.
- Sync operations must be idempotent and resumable.
- UI may request retry intent, but sync execution remains in offline/services/workers.

## State and UI Contract
- Redux tracks network/sync state and error codes.
- UI consumes state via selectors/hooks.
- UI must not run offline engine logic directly.

## Conflict Handling
- Default server-authoritative reconciliation unless feature contract defines otherwise.
- If user intervention is required, sync pauses and exposes a resolvable state.

## Security and Reliability
- Sensitive queued payloads follow `security.mdc` encryption requirements.
- Expired/invalid auth must block protected sync operations safely.

## Related Owners
- Service execution contracts for queued work: `services-integration.mdc`
- Redux integration: `state-management.mdc`
- Domain flow rules: `features-domain.mdc`
- Offline encryption and credential safeguards: `security.mdc`
- Test requirements: `testing.mdc`