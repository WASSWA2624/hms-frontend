Steps to review and implement (Phase 011 - Tier 4: Patient Registry and Consent):
- **11.4.1** Patients home - `(main)/patients`
- **11.4.2** Patients - `(main)/patients/patients` - backend `patient`
- **11.4.3** Patient identifiers - `(main)/patients/patient-identifiers` - backend `patient-identifier`
- **11.4.4** Patient contacts - `(main)/patients/patient-contacts` - backend `patient-contact`
- **11.4.5** Patient guardians - `(main)/patients/patient-guardians` - backend `patient-guardian`
- **11.4.6** Patient allergies - `(main)/patients/patient-allergies` - backend `patient-allergy`
- **11.4.7** Patient medical histories - `(main)/patients/patient-medical-histories` - backend `patient-medical-history`
- **11.4.8** Patient documents - `(main)/patients/patient-documents` - backend `patient-document`
- **11.4.9** Consents - `(main)/patients/consents` - backend `consent`
- **11.4.10** Terms acceptances - `(main)/patients/terms-acceptances` - backend `terms-acceptance`

Specific implementation scope for this tier:
- Implement selected screen/route wiring and interactions for this tier only.
- Ensure end-to-end backend linkage for enabled actions and read-only fallbacks for unsupported actions.
- Apply route/action access control, accessibility semantics, and resilient loading/error/offline states.

Review and implement all missing and non-compliant aspects of this selected tier per:
- hms-frontend/dev-plan/P011_screens-routes.md

You must ensure 100% compliance with:
- All rules in hms-frontend/.cursor/rules/*
- hms-frontend/write-up.md
- Contracts must align with `hms-backend/dev-plan/P010_api_endpoints.mdc`.
- Mounted routes in `hms-backend/src/app/router.js` and selected module route files are source of truth.
- Use only mounted backend resources/actions from `hms-backend/src/app/router.js`; if an action is absent in contract, keep role-aware read-only/informational UX.
- If backend changes are required, comply fully with `hms-backend/.cursor/rules/*`.
- Actual repository architecture and conventions already in hms-frontend/src/**

Only implement what is required for this tier's selected step(s).

## Mobile UI Parity and Compact UX Contract (Mandatory)

For any selected step that touches UI (components, screens, layouts, route presentation, copy, interactions, or styling):
- Android and iOS must visually and behaviorally match mobile web for layout density, typography scale, component sizing, spacing, and interaction patterns.
- Use shared-first implementations by default. Platform-specific override files are allowed only for hard platform/accessibility constraints and must preserve parity with mobile web.
- Keep UI simple, modern, compact, stable, and fully responsive across phone, tablet, and web breakpoints.
- Keep user journeys chronological and obvious for first-time users: clear actions, short labels, and minimal friction.
- Prefer consolidating related actions on one screen when it reduces fragmentation and cognitive load.
- Auto-resolve and hide known context parameters (tenant, facility, branch, user, encounter, and similar context) unless user input is mandatory by contract or compliance.
- Do not show internal model IDs in UI. Display human-readable business IDs/labels from backend or domain data contracts.
- Keep navigation straightforward with stable route structure, stable nav items, and consistent placement of controls.
- Reuse shared platform components/patterns/tokens first; avoid ad-hoc one-off UI implementations.
- Add concise contextual help for critical decisions and keep instructional copy short and local to the action.
- Keep full compliance with i18n, accessibility, and theme-token rules while applying this contract.

## Human-Readable Identity and Context Selection Contract (Mandatory)

For any selected step that touches UI, onboarding, auth, or context selection:
- Never display raw technical identifiers (UUID/GUID/internal primary keys) to non-super users.
- Keep technical IDs internal to state, route params, and API payloads; do not render them in labels, inputs, tables, cards, helper text, or summaries for standard users.
- Display human-readable names and business labels by default (tenant name, facility name, module name, plan name, invoice number, license code).
- If a visible identifier is required, use a human-readable business ID/code (for example `FAC-00124`) instead of raw GUID values.
- Once user email is captured/resolved in onboarding/auth flows, load authorized tenant/facility options from mounted backend resources and present readable names in checkbox/selectable list controls.
- Auto-resolve and hide IDs when only one authorized tenant/facility exists; otherwise let users choose from readable option lists.
- For privileged support/admin screens where technical IDs are required, gate visibility by role and keep default views human-readable.

---

## Total UI Component and Sub-Component Compliance Contract (Mandatory)

For any selected step that touches UI (components, screens, layouts, route presentation, copy, interactions, or styling):
- Review every impacted UI component and nested sub-component end-to-end, including conditional branches (tabs, modals, drawers, tables, cards, forms, field groups, action bars, empty/loading/error states).
- Assess each element for full compliance with this UX target: elegant, intuitive, modern, simple, self-explanatory, role-aware, minimal, quick to use, and chronologically organized.
- If any element is non-compliant, redesign it before completion (information hierarchy, interaction flow, copy, control placement, visual density, and component composition).
- Remove or merge redundant controls/sections to reduce clutter and shorten task time without hiding required clinical/business context.
- Ensure every primary workflow has clear chronological next actions and predictable back/forward handoffs.
- Enforce role-aware visibility and action readiness at component and sub-component level (not only at route level).
- Keep redesigned UI aligned with shared components/tokens and platform parity; avoid one-off visual patterns unless required by accessibility/compliance constraints.
- Document reviewed components, non-compliance findings, and redesign decisions in the final compliance report.
---
## Novice-First UX and Navigation Contract (Mandatory)

For any selected step that touches UI (components, screens, layouts, route presentation, copy, interactions, or styling):
- Design for first-time users with minimal or no prior training; every primary action must be obvious from context.
- Keep user journeys chronological and self-explanatory from start to completion; every next step must be clearly signposted.
- Make navigation between related screens easy and predictable with consistent placement, labels, and back/next patterns.
- Prefer progressive disclosure and role-focused context; show only what the current user needs to complete the current task.
- Pre-fill and auto-resolve known values from trusted context (tenant, facility, user, encounter, branch, etc.) and hide them unless confirmation or compliance visibility is required.
- Enforce strict role and permission visibility for routes, navigation items, widgets, fields, and actions.
- Do not surface unauthorized or irrelevant areas (for example, finance metrics for non-finance roles or registration flows for non-admin operational roles).
- Reuse predefined shared components and established design tokens before creating new UI patterns.
- Keep layouts space-efficient, lightweight, and performant; avoid visual clutter and long static instructions.
- Provide contextual in-app guidance with a help icon pattern; on hover/focus/press it must reveal a tooltip or modal that explains terms, fields, and decisions.
- Include concise guidance for domain sequencing where needed (for example, tenant vs facility and required creation order).
- Ensure terminology, labels, and helper text remain short, clear, and action-oriented across Android, iOS, and web.

---


## User-Friendly Errors and Recovery Contract (Mandatory)

For any selected step that touches UI (components, screens, layouts, route presentation, copy, interactions, or styling):
- Display errors in plain language that users can understand without technical training.
- Do not use ambiguous generic text such as "Something went wrong" or "Server error" without context.
- Prefer specific, user-centered messages (for example, "We could not load facility data right now").
- Provide immediate, actionable next steps in the UI (retry, check connection, refresh, confirm permissions, continue in read-only mode when appropriate).
- Distinguish user-correctable issues from system-side issues and tailor guidance accordingly.
- Map validation and business-rule failures to field-level or action-level messages near the relevant control.
- Keep sensitive internals out of UI messages (no stack traces, SQL/errors, secrets, or internal identifiers).
- Store technical diagnostics in logs and telemetry only; surface concise user-facing guidance in the screen.
- For persistent system errors, provide a support handoff path with a user-friendly incident reference and clear instruction to contact support if retries fail.
- Ensure all error/help text remains concise, localized, accessible, and role-appropriate.
- Use contextual help triggers (help icon / tooltip / modal) to clarify domain terms and required action order when confusion is likely.

## Interconnected Functionality Coordination Contract (Mandatory)

For any selected step that touches UI (components, screens, layouts, route presentation, copy, interactions, or styling):
- Treat related screens and features as one coordinated workflow, not isolated pages.
- Verify upstream and downstream dependencies so updates in one area correctly reflect in all linked areas.
- Keep identifiers, statuses, timestamps, ownership fields, and state transitions consistent across connected modules.
- Ensure actions in one screen (create/update/approve/cancel/assign/close) propagate clearly to dependent queues, summaries, detail views, and dashboards.
- Provide explicit cross-screen navigation handoffs (next step, related records, return path) where workflows span multiple modules.
- Align validation and business rules across interconnected forms to prevent contradictory outcomes between screens.
- Enforce role and permission coordination across linked flows so users only see and trigger actions they are authorized for end-to-end.
- Use shared domain components, hooks, and contracts to avoid duplicated logic and drift between connected features.
- Handle partial failure/offline scenarios with clear reconciliation behavior so linked records do not silently diverge.
- Include cross-functional test coverage for linked journeys, including success, validation, permission-denied, and recovery paths.
## Role-Based Visibility and Access Enforcement Contract (Mandatory)

For any selected step that touches auth, routing, navigation, data access, or UI:
- Users must never see or execute anything outside their role and permission scope.
- Ensure each role sees the routes, nav items, screens, sections, components, and actions required for their responsibilities; missing required access is a defect.
- Enforce access at multiple layers: menu item visibility, route/screen guards, section-level rendering, component-level rendering, and action/function-level handlers.
- Hide unauthorized menu items, tabs, widgets, buttons, fields, cards, and screen sections by default; do not expose privileged controls unless explicitly required by approved requirements.
- Determine navigation visibility from the logged-in user's role set; show main and nested nav items only when those roles are authorized for the linked routes/screens.
- Block unauthorized function/action execution even when UI is bypassed (direct URL entry, deep links, state tampering, manual event triggering).
- Use a single source of truth for access checks across web, Android, and iOS to prevent behavior drift.
- Use canonical backend role names and permission contracts as defined by `hms-backend/.cursor/rules/index.mdc` and backend auth/rbac contracts.
- Provide deterministic denied-access UX (safe redirect, read-only fallback, or localized permission message) without leaking sensitive details.
- Add/update tests that verify protected and required role paths: menu visibility, required route availability, route guards, screen/section/component rendering, and denied function/action paths.

---

## Rule Loading Contract (Mandatory)

Before coding, read and apply:
- `hms-frontend/.cursor/rules/index.mdc` (entry point)
- `hms-frontend/.cursor/rules/core-principles.mdc`
- `hms-frontend/.cursor/rules/tech-stack.mdc`
- `hms-frontend/.cursor/rules/dependency-policy.mdc`
- `hms-frontend/.cursor/rules/project-structure.mdc`
- `hms-frontend/.cursor/rules/app-router.mdc`
- `hms-frontend/.cursor/rules/platform-ui.mdc`
- `hms-frontend/.cursor/rules/component-structure.mdc`
- `hms-frontend/.cursor/rules/theme-design.mdc`
- `hms-frontend/.cursor/rules/state-management.mdc`
- `hms-frontend/.cursor/rules/features-domain.mdc`
- `hms-frontend/.cursor/rules/services-integration.mdc`
- `hms-frontend/.cursor/rules/hooks-utils.mdc`
- `hms-frontend/.cursor/rules/offline-sync.mdc`
- `hms-frontend/.cursor/rules/security.mdc`
- `hms-frontend/.cursor/rules/i18n.mdc`
- `hms-frontend/.cursor/rules/accessibility.mdc`
- `hms-frontend/.cursor/rules/performance.mdc`
- `hms-frontend/.cursor/rules/errors-logging.mdc`
- `hms-frontend/.cursor/rules/debug.mdc`
- `hms-frontend/.cursor/rules/bootstrap-config.mdc`
- `hms-frontend/.cursor/rules/coding-conventions.mdc`
- `hms-frontend/.cursor/rules/testing.mdc`

---

## Tier Step Selection Contract (Mandatory)

- This file covers only the listed step IDs for Phase 011 Tier 4.
- If specific step IDs from this tier are selected, implement only those IDs.
- If the tier is selected as a whole, implement all listed step IDs in order.
- If shared prerequisite wiring is required, implement only the minimum required for this tier.
- Do NOT implement unselected sibling tiers or out-of-tier steps.

---

## Implementation Areas

Primary areas for this tier:
- `src/app/**` route files and group layouts for selected tier step(s)
- Selected `src/features/**`, `src/hooks/**`, and form components required by tier screens
- Tests under `src/__tests__/**` covering selected tier routes, actions, and edge states

---

## Tier Constraints (Mandatory)

- Do NOT implement steps from other tiers unless minimal prerequisite wiring is required.
- Do NOT call non-mounted backend endpoints or invent shortcut routes.
- Do NOT bypass route-level auth/role guards.

---

## Tier Gate Checklist

1. Implement/fix only selected step(s) within this tier.
2. Enforce i18n/accessibility/rules compliance.
3. Add/update tests and edge-path coverage for selected step(s).
4. Run relevant checks/tests and report results.
5. Verify no architecture boundary violations.
6. Verify no out-of-tier scope creep.
7. Complete and document a full UI component/sub-component compliance review for selected step(s), redesigning non-compliant UI where needed.

---

## Deliverables

Return ONLY:

1. Implementation files changed for selected step(s) in this tier.
2. Related exports/wiring updates required by selected step(s) only.
3. i18n locale key updates required by selected step(s).
4. Tests/check commands run and result summary.
5. A concise compliance report confirming selected step IDs, full UI component/sub-component review outcomes, redesign actions taken where needed, rule checks, backend/write-up alignment checks, and any justified out-of-scope deferrals.

Do NOT include files or logic outside this tier's selected step(s).
