Global shared contracts for Phase 011 screens/routes.
Load and apply this file before any other prompt file in this folder tree (index, tier README, or step file).

## Global Applicability and Precedence (Mandatory)

- This contract applies automatically to every `.mdc` prompt under `hms-frontend/.cursor/commands/dev-phase-011-screens-routes/**`.
- Covered files include `index-screens-routes.mdc`, all tier `README.mdc` files, and all step prompt files (`11_**_**_*.mdc`).
- Any task initiated from any covered prompt is invalid unless this contract is loaded and enforced first.
- This contract is normative and non-overridable for Phase 011 prompts in this folder tree.
- If any covered prompt conflicts with this contract, this contract takes precedence.
- Covered prompts may narrow selected scope, but may not relax, remove, or bypass any mandatory requirement in this contract.
- Completion for any selected scope requires explicit compliance with every mandatory section in this contract.

## Prompt Inheritance Enforcement (Mandatory)

- Every covered prompt file must include a `Shared Contract Enforcement (Mandatory)` section that references this contract.
- The inheritance section in covered prompt files is declarative only; it does not supersede or rewrite this contract.
- Every covered prompt file must treat the guide/help synchronization and responsive list-rendering rules in this contract as required acceptance criteria.

## Supplemental Tier Notes
## Concrete Parity Checklist for `11.10.12` (`(main)/hr/staff-positions`)

Run this after `11.10.11` is complete.

- [ ] Create route files:
  - `src/app/(main)/hr/staff-positions/index.jsx`
  - `src/app/(main)/hr/staff-positions/create.jsx`
  - `src/app/(main)/hr/staff-positions/[id].jsx`
  - `src/app/(main)/hr/staff-positions/[id]/edit.jsx`
- [ ] Use generic resource wrappers with `resourceId="staff-positions"`:
  - list -> `ClinicalResourceListScreen`
  - create -> `ClinicalResourceFormScreen`
  - detail -> `ClinicalResourceDetailScreen`
  - edit -> `ClinicalResourceFormScreen`
- [ ] Confirm shared wiring:
  - `src/config/sideMenu.js` includes `/hr/staff-positions`
  - `src/i18n/locales/en.json` includes `main-nav.hr-staff-positions`
  - `src/platform/screens/clinical/ClinicalResourceConfigs.js` includes `staff-positions`
  - `src/platform/screens/clinical/useClinicalResourceCrud.js` maps `CLINICAL_RESOURCE_IDS.STAFF_POSITIONS`
- [ ] Update route coverage:
  - `src/__tests__/app/(main)/tier-10-routes.test.js` add `'staff-positions'` in `RESOURCES_WITH_EDIT.hr`
- [ ] Verify:
  - `npm run test -- "src/__tests__/app/(main)/tier-10-routes.test.js"`
  - `npm run test -- src/__tests__/platform/screens/clinical/clinicalResourceConfigs.test.js`
  - navigate `/hr/staff-positions`, `/hr/staff-positions/create`, `/hr/staff-positions/:id`, `/hr/staff-positions/:id/edit`

Specific implementation scope for this selected scope:
- Implement selected screen/route wiring and interactions for selected tier/step IDs only.
- Ensure end-to-end backend linkage for enabled actions and role-aware fallbacks when API contract or entitlement blocks an action.
- Apply route/action access control, accessibility semantics, and resilient loading/error/offline states.

Review and implement all missing and non-compliant aspects of this selected scope per:
- hms-frontend/dev-plan/P011_screens-routes.md

You must ensure 100% compliance with:
- All rules in hms-frontend/.cursor/rules/*
- hms-frontend/write-up.md
- Contracts must align with `hms-backend/dev-plan/P010_api_endpoints.mdc`.
- Mounted routes in `hms-backend/src/app/router.js` and selected module route files are source of truth.
- Use only mounted backend resources/actions from `hms-backend/src/app/router.js`; do not invent unsupported endpoints.
- If backend changes are required, comply fully with `hms-backend/.cursor/rules/*`.
- Actual repository architecture and conventions already in hms-frontend/src/**

Only implement what is required for selected step(s).

## Pagination Limit Safety and Type Contract (Mandatory)

For any selected step that reads list data, dashboard aggregates, or paginated resources:
- Frontend request pagination must always align with backend limits defined in `hms-backend/src/config/constants.js` (`MAX_PAGE_LIMIT`, currently `100`).
- Do not send list/query `limit` values above backend `MAX_PAGE_LIMIT` under any workflow, including dashboards, preload batches, and reference lookups.
- Do not hardcode oversized values (for example `200`, `250`, `500`) in list/query calls; use shared capped constants or helpers only.
- Coerce pagination params to numbers before API calls, then clamp to `[1, MAX_PAGE_LIMIT]`; never pass string values to data-layer pagination inputs.
- When user preferences or URL params contain invalid values, fail safe by applying default bounded values instead of forwarding raw input.
- Keep one shared pagination normalization path per screen family/module to prevent drift across web, iOS, and Android variants.
- Add/update tests that assert outbound list params are numeric and capped at `MAX_PAGE_LIMIT` for all touched list/dashboard hooks.
- Treat repeated backend validation errors for `limit` (400/Zod) or Prisma `take` type mismatches as blocking defects; fix source params/contracts before completion.

## Mobile UI Parity and Compact UX Contract (Mandatory)

UI applicability note for the contracts in this block: unless a section states otherwise, each applies to any selected step that touches UI (components, screens, layouts, route presentation, copy, interactions, or styling).
- Android and iOS must visually and behaviorally match mobile web for layout density, typography scale, component sizing, spacing, and interaction patterns.
- Use shared-first implementations by default. Platform-specific override files are allowed only for hard platform/accessibility constraints and must preserve parity with mobile web.
- Keep UI simple, modern, compact, stable, and fully responsive across phone, tablet, and web breakpoints.
- Keep user journeys chronological and obvious for first-time users: clear actions, short labels, and minimal friction.
- Prefer consolidating related actions on one screen when it reduces fragmentation and cognitive load.
- Auto-resolve and hide known context parameters (tenant, facility, branch, user, encounter, and similar context) unless user input is mandatory by contract or compliance.
- Do not show internal model IDs in UI. Display human-readable business IDs/labels from backend or domain data contracts.
- Keep navigation straightforward with stable route structure, stable nav items, and consistent placement of controls.
- Reuse shared platform components/patterns/tokens first; avoid ad-hoc one-off UI implementations.
- Add concise contextual help for critical decisions and keep instructional copy short and local to the action.
- Keep full compliance with i18n, accessibility, and theme-token rules while applying this contract.

## Comprehensive Create/Edit Form Coverage and Input Strategy Contract (Mandatory)

For any selected step that touches add/create/edit forms:
- Forms must capture the maximum practical set of writable business fields available from mounted backend resource contracts and shared resource configs; do not ship thin forms that omit useful writable fields without explicit scope justification.
- Create and edit forms must maintain field parity for writable fields. Allowed differences are limited to immutable/system-managed fields and role-restricted fields.
- Auto-resolve and hide pre-known context fields (for example tenant, facility, branch, encounter, provider, current user) when sourced from trusted app/session/route context.
- Do not ask users to manually input system-managed or backend-generated fields (`id`, UUIDs, `created_at`, `updated_at`, `deleted_at`, `version`, `etag`, audit-only metadata), unless an approved compliance flow explicitly requires visibility.
- If a pre-known field is required for compliance visibility, render it as read-only contextual information instead of editable free input.
- Any field backed by enums, finite option sets, or relational table/resource options must use selection controls (for example `Select`, searchable select/autocomplete, segmented controls, radio groups, toggle groups, switches), not unconstrained text input.
- Boolean fields must use toggles/switches or equivalent binary controls; do not model booleans with free-text fields.
- Foreign-key/reference fields must use readable labels from mounted resource lookups and hide raw technical IDs from standard users.
- Organize long forms into clear, chronological sections with concise headers and helper copy; keep advanced/rare fields collapsed behind progressive disclosure by default.
- Provide sensible defaults, inline validation, and clear error recovery near each field/action to reduce correction effort.
- Edit forms must prefill existing values and clearly separate editable vs non-editable fields.
- Reuse shared form primitives and patterns (`FormField`, shared selectors, validation schemas, shared section wrappers) before introducing one-off local field components.
- Add/update tests to verify: required field presence, hidden pre-known field behavior, selector usage for enum/table-backed inputs, and create/edit parity for core writable fields.

## Shared-First Parent Abstraction Contract (Mandatory)

For any selected step that touches route files, screens, components, hooks, utilities, or screen behavior:
- Treat repeated components, logic, and behaviors as defects to be refactored, not duplicated.
- If UI/behavior appears in 2+ places (or is expected to recur across sibling routes), extract it to a shared parent layer before completion.
- Move repeated UI primitives/compositions to shared/base components in existing shared component families (for example `src/platform/components/**`) instead of per-screen inline copies.
- Move repeated screen shells and structural wrappers (title/help header blocks, action bars, list/form scaffolds, shared state surfaces) to shared layouts/wrappers (for example `src/platform/layouts/**` or route-group `_layout.jsx`).
- Move repeated orchestration/state logic (query wiring, permission guards, mutation flows, retry/offline handling, cross-screen navigation handoffs) into shared hooks/screen abstractions (for example `src/hooks/**` or `src/platform/screens/**`).
- Move repeated pure helpers (formatting, normalization, mapping, filtering, pagination, permission predicates, validation helpers) into shared utility modules (for example `src/utils/**`) as a single source of truth.
- Centralize repeated constants/config maps (resource IDs, route metadata, action definitions, filter schemas, table defaults) in shared config/contracts rather than re-declaring per screen.
- Prefer extending an existing parent/shared abstraction over creating a new one-off local variant when capability overlap exists.
- Keep parent abstractions configurable (props/options/callbacks) so module-specific behavior does not require forks.
- Do not ship copy-pasted handlers, duplicated validation branches, duplicated table/list behavior, or duplicated layout scaffolding across selected scope files.
- When extracting shared code, update all touched selected-scope consumers to use the parent abstraction in the same change set.
- Add/update tests at the shared abstraction layer plus at least one consuming screen/route to guard reuse and prevent behavior drift.
- Final compliance output must explicitly list extracted parent components/layouts/hooks/utilities and justify any temporary non-extracted duplication with a follow-up step.

## Responsive List Presentation and Customizable Data Grid Contract (Mandatory)

For any selected step that exposes a list/index route or collection view:
- Desktop and tablet web breakpoints must always render list data using the shared `DataTable` component (or approved shared table wrapper built on `DataTable`).
- Mobile breakpoints must always render the same records using shared `List` + `ListItem` patterns (or approved shared wrappers built on those components), optimized for compact vertical density and thumb-friendly actions.
- Do not replace mobile list/list-item flows with desktop table grid layouts. Do not replace desktop/tablet table flows with mobile card-only layouts.
- Use one shared data source and consistent RBAC policy across table/list variants so visible rows, counts, and allowed actions stay in sync on all platforms.
- Desktop/tablet tables must expose the maximum practical set of business-relevant fields for the resource, including workflow-critical fields from related mounted tables/resources when available.
- Mobile list items must preserve the same core information hierarchy as the table (with compact presentation), including related context labels that are necessary for safe user decisions.
- Related-table fields must be resolved through mounted backend includes/expansions or shared lookup composition in hooks; do not skip high-value related columns only to avoid mapping/join effort.
- Foreign-key columns in table/list views must render human-readable related labels/codes (for example tenant/facility/patient/provider names) instead of raw IDs for standard users.
- Default visible table columns must include key identity, status, ownership/context, chronology, and related business context; optional/advanced columns may be hidden behind column-visibility controls.
- Search/filter/sort contracts must include mapped related fields when those fields are displayed as table/list columns.
- Add/update tests to verify related-field column rendering, related-label fallback behavior, and parity of critical related context between table and mobile list variants.
- Table and mobile list item actions (view/create/edit/delete/restore/export/bulk operations) must be shown or hidden by role/permission and guarded in handlers to block unauthorized execution.
- Desktop/tablet `DataTable` implementations must always include a built-in export + print capability at component level (not per-screen duplication), with a minimal trigger button that opens a comprehensive modal for export/print configuration.
- `DataTable` filter/export utility sections must be collapsed (hidden) by default to preserve vertical space and must expose a minimal explicit toggle button to reveal them.
- The `Export` button must live in the `Filters` section header and be positioned immediately to the left of the expand/collapse control.
- The shared `DataTable` export modal must use a basic-first layout: always show core format/scope + primary action, and keep advanced options collapsed behind an explicit toggle by default.
- The shared `DataTable` export modal must support at least CSV, Excel-compatible export, PDF export, and print output; this requirement is mandatory for all list/index routes that render `DataTable`.
- `DataTable` exports and prints must be filter-aware by default: output must reflect the currently active filtered dataset (and any selected scope options) rather than unfiltered source rows.
- For any web screen/route that renders `DataTable` (or approved shared wrappers built on `DataTable`), the hook-level active criteria signal must be passed into `DataTable` as `hasActiveFilters` so filter tools auto-open when active criteria exist.
- If a table/list hook does not yet expose `hasActiveSearchOrFilter`, it must add an equivalent computed signal from current search/filter state and wire it to `DataTable.hasActiveFilters`; module-specific or screen-specific exceptions are not allowed.
- All shared `DataTable` control and export-modal strings (titles, labels, toggles, status feedback, and no-rows export fallbacks) must be i18n-driven from `common.dataTable.*`; do not ship hardcoded UI copy in `DataTable`.
- Any route that still uses a non-`DataTable` desktop/tablet table implementation (for example transitional screens such as `UserSessionListScreen`) must adopt the same shared `DataTable` contracts above when touched in scope.
- Provide global search plus field-scoped search so users can query every searchable business field exposed in the dataset contract.
- Support advanced filters with multi-condition criteria (field, operator, value, AND/OR grouping) and clear reset behavior.
- On desktop/tablet table views, keep the advanced filter section collapsed by default and reveal it only on explicit user toggle.
- Support sortable columns with stable sort state and deterministic server/client fallback behavior.
- Support column visibility toggles and drag/drop (or equivalent) column reordering on desktop/tablet tables.
- Persist per-user table preferences (visible columns, order, sort, filters, density, and page size) when storage contracts exist; otherwise keep deterministic session defaults.
- Keep row-level and bulk actions discoverable, compact, and horizontally aligned, with destructive actions visually differentiated.
- Keep table/list states complete: loading, empty, no-search-results, permission-denied, offline, and recoverable error with actionable retry guidance.
- Ensure accessibility parity for search, filters, column controls, row actions, and keyboard/screen-reader navigation on web and assistive flows.
- Add/update tests for responsive rendering mode switching, all-field search behavior, advanced filtering, RBAC action visibility/guards, and column customization persistence.

## Human-Readable Identity and Context Selection Contract (Mandatory)
For any selected step that touches UI, onboarding, auth, or context selection:
- Never display raw technical identifiers (UUID/GUID/internal primary keys) to non-super users.
- Keep technical IDs internal to state, route params, and API payloads; do not render them in labels, inputs, tables, cards, helper text, or summaries for standard users.
- Display human-readable names and business labels by default (tenant name, facility name, module name, plan name, invoice number, license code).
- If a visible identifier is required, use a human-readable business ID/code (for example `FAC-00124`) instead of raw GUID values.
- Once user email is captured/resolved in onboarding/auth flows, load authorized tenant/facility options from mounted backend resources and present readable names in checkbox/selectable list controls.
- Auto-resolve and hide IDs when only one authorized tenant/facility exists; otherwise let users choose from readable option lists.
- For privileged support/admin screens where technical IDs are required, gate visibility by role and keep default views human-readable.

---

## Total UI Component and Sub-Component Compliance Contract (Mandatory)

- Review every impacted UI component and nested sub-component end-to-end, including conditional branches (tabs, modals, drawers, tables, cards, forms, field groups, action bars, empty/loading/error states).
- Assess each element for full compliance with this UX target: elegant, intuitive, modern, simple, self-explanatory, role-aware, minimal, quick to use, and chronologically organized.
- If any element is non-compliant, redesign it before completion (information hierarchy, interaction flow, copy, control placement, visual density, and component composition).
- Remove or merge redundant controls/sections to reduce clutter and shorten task time without hiding required clinical/business context.
- Ensure every primary workflow has clear chronological next actions and predictable back/forward handoffs.
- Enforce role-aware visibility and action readiness at component and sub-component level (not only at route level).
- Keep redesigned UI aligned with shared components/tokens and platform parity; avoid one-off visual patterns unless required by accessibility/compliance constraints.
- Document reviewed components, non-compliance findings, and redesign decisions in the final compliance report.
---
## Novice-First UX and Navigation Contract (Mandatory)

- Design for first-time users with minimal or no prior training; every primary action must be obvious from context.
- Keep user journeys chronological and self-explanatory from start to completion; every next step must be clearly signposted.
- Make navigation between related screens easy and predictable with consistent placement, labels, and back/next patterns.
- Prefer progressive disclosure and role-focused context; show only what the current user needs to complete the current task.
- Pre-fill and auto-resolve known values from trusted context (tenant, facility, user, encounter, branch, etc.) and hide them unless confirmation or compliance visibility is required.
- Enforce strict role and permission visibility for routes, navigation items, widgets, fields, and actions.
- Do not surface unauthorized or irrelevant areas (for example, finance metrics for non-finance roles or registration flows for non-admin operational roles).
- Reuse predefined shared components and established design tokens before creating new UI patterns.
- Keep layouts space-efficient, lightweight, and performant; avoid visual clutter and long static instructions.
- Provide contextual in-app guidance with a help icon pattern; on hover/focus/press it must reveal a tooltip or modal that explains terms, fields, and decisions.
- Include concise guidance for domain sequencing where needed (for example, tenant vs facility and required creation order).
- Ensure terminology, labels, and helper text remain short, clear, and action-oriented across Android, iOS, and web.

---


## Screen-Specific Title and In-Screen Guide Contract (Mandatory)

- Every active route/screen must present a screen-specific primary title and a screen-specific in-app guide/help payload.
- Any screen update (layout, controls, actions, copy, behavior, state handling, or workflow order) must include a guide/help review and update in the same change set so guidance stays accurate.
- If a screen change does not require guide/help wording changes, explicitly confirm guide/help validation in the compliance report for that step.
- Do not stack duplicated parent shell titles/subtitles with child-screen titles. Keep one primary title for the active screen context.
- If a shared shell/header is used, derive the displayed title/help from the current child route and update it immediately on route change.
- Title and guide text must use the active module/workflow name (for example, "Tenants", "Facilities", "User Roles") rather than generic route labels.
- In-screen guide/help must be comprehensive and clear: purpose, prerequisites, ordered steps, role/permission constraints, and recovery actions.
- Guide/help content must stay scannable (short sections or bullets) while still covering the complete workflow and key decisions.
- Apply this pattern consistently across web, Android, and iOS with the same information hierarchy and behavior.

---
## User-Friendly Errors and Recovery Contract (Mandatory)

- Display errors in plain language that users can understand without technical training.
- Do not use ambiguous generic text such as "Something went wrong" or "Server error" without context.
- Prefer specific, user-centered messages (for example, "We could not load facility data right now").
- Provide immediate, actionable next steps in the UI (retry, check connection, refresh, confirm permissions, continue in read-only mode when appropriate).
- Distinguish user-correctable issues from system-side issues and tailor guidance accordingly.
- Map validation and business-rule failures to field-level or action-level messages near the relevant control.
- Keep sensitive internals out of UI messages (no stack traces, SQL/errors, secrets, or internal identifiers).
- Store technical diagnostics in logs and telemetry only; surface concise user-facing guidance in the screen.
- For persistent system errors, provide a support handoff path with a user-friendly incident reference and clear instruction to contact support if retries fail.
- Ensure all error/help text remains concise, localized, accessible, and role-appropriate.
- Use contextual help triggers (help icon / tooltip / modal) to clarify domain terms and required action order when confusion is likely.

## Interconnected Functionality Coordination Contract (Mandatory)

- Treat related screens and features as one coordinated workflow, not isolated pages.
- Verify upstream and downstream dependencies so updates in one area correctly reflect in all linked areas.
- Keep identifiers, statuses, timestamps, ownership fields, and state transitions consistent across connected modules.
- Ensure actions in one screen (create/update/approve/cancel/assign/close) propagate clearly to dependent queues, summaries, detail views, and dashboards.
- Provide explicit cross-screen navigation handoffs (next step, related records, return path) where workflows span multiple modules.
- Align validation and business rules across interconnected forms to prevent contradictory outcomes between screens.
- Enforce role and permission coordination across linked flows so users only see and trigger actions they are authorized for end-to-end.
- Use shared domain components, hooks, and contracts to avoid duplicated logic and drift between connected features.
- Handle partial failure/offline scenarios with clear reconciliation behavior so linked records do not silently diverge.
- Include cross-functional test coverage for linked journeys, including success, validation, permission-denied, and recovery paths.
## Role-Based Visibility and Access Enforcement Contract (Mandatory)

For any selected step that touches auth, routing, navigation, data access, or UI:
- Users must never see or execute anything outside their role and permission scope.
- Ensure each role sees the routes, nav items, screens, sections, components, and actions required for their responsibilities; missing required access is a defect.
- Enforce access at multiple layers: menu item visibility, route/screen guards, section-level rendering, component-level rendering, and action/function-level handlers.
- Hide unauthorized menu items, tabs, widgets, buttons, fields, cards, and screen sections by default; do not expose privileged controls unless explicitly required by approved requirements.
- Determine navigation visibility from the logged-in user's role set; show main and nested nav items only when those roles are authorized for the linked routes/screens.
- Block unauthorized function/action execution even when UI is bypassed (direct URL entry, deep links, state tampering, manual event triggering).
- Use a single source of truth for access checks across web, Android, and iOS to prevent behavior drift.
- Use canonical backend role names and permission contracts as defined by `hms-backend/.cursor/rules/index.mdc` and backend auth/rbac contracts.
- Provide deterministic denied-access UX (safe redirect, read-only fallback, or localized permission message) without leaking sensitive details.
- Add/update tests that verify protected and required role paths: menu visibility, required route availability, route guards, screen/section/component rendering, and denied function/action paths.

---

## Rule Loading Contract (Mandatory)

Before coding, read and apply:
- `hms-frontend/.cursor/rules/index.mdc` (entry point)
- `hms-frontend/.cursor/rules/core-principles.mdc`
- `hms-frontend/.cursor/rules/tech-stack.mdc`
- `hms-frontend/.cursor/rules/dependency-policy.mdc`
- `hms-frontend/.cursor/rules/project-structure.mdc`
- `hms-frontend/.cursor/rules/app-router.mdc`
- `hms-frontend/.cursor/rules/platform-ui.mdc`
- `hms-frontend/.cursor/rules/component-structure.mdc`
- `hms-frontend/.cursor/rules/theme-design.mdc`
- `hms-frontend/.cursor/rules/state-management.mdc`
- `hms-frontend/.cursor/rules/features-domain.mdc`
- `hms-frontend/.cursor/rules/services-integration.mdc`
- `hms-frontend/.cursor/rules/hooks-utils.mdc`
- `hms-frontend/.cursor/rules/offline-sync.mdc`
- `hms-frontend/.cursor/rules/security.mdc`
- `hms-frontend/.cursor/rules/i18n.mdc`
- `hms-frontend/.cursor/rules/accessibility.mdc`
- `hms-frontend/.cursor/rules/performance.mdc`
- `hms-frontend/.cursor/rules/errors-logging.mdc`
- `hms-frontend/.cursor/rules/debug.mdc`
- `hms-frontend/.cursor/rules/bootstrap-config.mdc`
- `hms-frontend/.cursor/rules/coding-conventions.mdc`
- `hms-frontend/.cursor/rules/testing.mdc`

---

## Tier Step Selection Contract (Mandatory)

- This file applies to all tier folders under `dev-phase-011-screens-routes`.
- If specific step IDs are selected, implement only those IDs after confirming all earlier step IDs in this phase are already complete; if not, complete missing earlier steps first (no chronology skips).
- If an entire tier folder is selected, implement all steps in that tier in numeric order.
- If shared prerequisite wiring is required, implement only the minimum required for the selected scope.
- Do NOT implement unselected sibling tiers or out-of-scope steps unless an earlier required prerequisite is needed to satisfy mandatory chronology gates.

---

## Implementation Areas

Primary areas for selected scope:
- `src/app/**` route files and group layouts for selected step(s)
- Selected `src/features/**`, `src/hooks/**`, and form components required by tier screens
- Tests under `src/__tests__/**` covering selected routes, actions, and edge states

---

## Scope Constraints (Mandatory)

- Do NOT implement steps from unselected tiers unless minimal prerequisite wiring is required.
- Do NOT call non-mounted backend endpoints or invent shortcut routes.
- Do NOT bypass route-level auth/role guards.

---

## Scope Gate Checklist

1. Implement/fix only selected step(s) within selected scope.
2. Enforce i18n/accessibility/rules compliance.
3. Add/update tests and edge-path coverage for selected step(s).
4. Run relevant checks/tests and report results.
5. Verify no architecture boundary violations.
6. Verify no out-of-tier scope creep.
7. Complete and document a full UI component/sub-component compliance review for selected step(s), redesigning non-compliant UI where needed.
8. Verify repeated components/logic/behaviors in selected scope were moved to parent shared layers (base components, layouts, hooks, utilities, or shared configs) or explicitly deferred with justification.
9. Verify create/edit forms in selected scope capture broad writable field coverage, hide pre-known context fields, and avoid exposing system-managed fields.
10. Verify enum/table-backed fields use selection controls (select/autocomplete/toggle/segmented/radio/switch) instead of free-text inputs.
11. Verify list/index table and mobile list surfaces in selected scope include broad business field coverage, including required related-table context rendered as human-readable labels.

---

## Deliverables

Return ONLY:

1. Implementation files changed for selected step(s).
2. Related exports/wiring updates required by selected step(s) only.
3. i18n locale key updates required by selected step(s).
4. Tests/check commands run and result summary.
5. A concise compliance report confirming selected step IDs, full UI component/sub-component review outcomes, redesign actions taken where needed, rule checks, backend/write-up alignment checks, and any justified out-of-scope deferrals.
6. Explicit guide/help synchronization confirmation for every updated screen (updated text or validated-as-current statement), plus responsive list-mode confirmation (`DataTable` on desktop/tablet web and `List` + `ListItem` on mobile).
7. Form coverage summary for selected create/edit routes, including hidden pre-known fields and selector-control mapping for enum/table-backed fields.
8. List/table field-coverage summary for selected index routes, including related-table fields displayed, human-readable mapping used, and any justified related-data gaps.

Do NOT include files or logic outside selected step(s).

