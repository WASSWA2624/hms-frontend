Steps to review and implement (Phase 000: Project Setup and Initialization):
- **0.1** Initialize Expo Project
- **0.2** Install Redux Toolkit Stack
- **0.3** Install Styled Components
- **0.4** Install Validation Library
- **0.5** Install Testing Dependencies
- **0.6** Install i18n Dependencies
- **0.7** Install Storage Dependencies
- **0.8** Install Network Detection
- **0.9** Install Expo Modules
- **0.10** Install React Native Core Dependencies
- **0.11** Install PWA Dependencies
- **0.12** Install Linting Dependencies
- **0.13** Verify All Dependencies
- **0.14** Create Project Structure
- **0.15** Configure Babel with Aliases
- **0.16** Create Debug Folder Structure and npm Scripts
- **0.17** Configure Metro Bundler
- **0.18** Configure ESLint & Prettier
- **0.19** Configure Jest
- **0.20** Create .gitignore
- **0.21** Verify Setup

Review and implement all missing and non-compliant aspects of the selected Phase 000 step(s) per:
- `hms-frontend/dev-plan/P000_setup.md`

You must ensure 100% compliance with:
- All rules in `hms-frontend/.cursor/rules/*`
- `hms-frontend/write-up.md`
- For any API host/version config touched in selected setup steps, keep parity with `hms-backend/src/app/router.js` versioning (`/api/v1`) and root health routes (`/health`, `/ready`, `/live`).
- Actual repository architecture and conventions already in `hms-frontend/src/**`

Only implement what is required for the selected Phase 000 step(s).

## Mobile UI Parity and Compact UX Contract (Mandatory)

For any selected step that touches UI (components, screens, layouts, route presentation, copy, interactions, or styling):
- Android and iOS must visually and behaviorally match mobile web for layout density, typography scale, component sizing, spacing, and interaction patterns.
- Use shared-first implementations by default. Platform-specific override files are allowed only for hard platform/accessibility constraints and must preserve parity with mobile web.
- Keep UI simple, modern, compact, stable, and fully responsive across phone, tablet, and web breakpoints.
- Keep user journeys chronological and obvious for first-time users: clear actions, short labels, and minimal friction.
- Prefer consolidating related actions on one screen when it reduces fragmentation and cognitive load.
- Auto-resolve and hide known context parameters (tenant, facility, branch, user, encounter, and similar context) unless user input is mandatory by contract or compliance.
- Do not show internal model IDs in UI. Display human-readable business IDs/labels from backend or domain data contracts.
- Keep navigation straightforward with stable route structure, stable nav items, and consistent placement of controls.
- Reuse shared platform components/patterns/tokens first; avoid ad-hoc one-off UI implementations.
- Add concise contextual help for critical decisions and keep instructional copy short and local to the action.
- Keep full compliance with i18n, accessibility, and theme-token rules while applying this contract.

---
## Role-Based Visibility and Access Enforcement Contract (Mandatory)

For any selected step that touches auth, routing, navigation, data access, or UI:
- Users must never see or execute anything outside their role and permission scope.
- Ensure each role sees the routes, nav items, screens, sections, components, and actions required for their responsibilities; missing required access is a defect.
- Enforce access at multiple layers: menu item visibility, route/screen guards, section-level rendering, component-level rendering, and action/function-level handlers.
- Hide unauthorized menu items, tabs, widgets, buttons, fields, cards, and screen sections by default; do not expose privileged controls unless explicitly required by approved requirements.
- Block unauthorized function/action execution even when UI is bypassed (direct URL entry, deep links, state tampering, manual event triggering).
- Use a single source of truth for access checks across web, Android, and iOS to prevent behavior drift.
- Use canonical backend role names and permission contracts as defined by `hms-backend/.cursor/rules/index.mdc` and backend auth/rbac contracts.
- Provide deterministic denied-access UX (safe redirect, read-only fallback, or localized permission message) without leaking sensitive details.
- Add/update tests that verify protected and required role paths: menu visibility, required route availability, route guards, screen/section/component rendering, and denied function/action paths.

---

## Rule Loading Contract (Mandatory)

Before coding, read and apply:
- `hms-frontend/.cursor/rules/index.mdc` (entry point)
- `hms-frontend/.cursor/rules/core-principles.mdc`
- `hms-frontend/.cursor/rules/tech-stack.mdc`
- `hms-frontend/.cursor/rules/dependency-policy.mdc`
- `hms-frontend/.cursor/rules/project-structure.mdc`
- `hms-frontend/.cursor/rules/app-router.mdc`
- `hms-frontend/.cursor/rules/platform-ui.mdc`
- `hms-frontend/.cursor/rules/component-structure.mdc`
- `hms-frontend/.cursor/rules/theme-design.mdc`
- `hms-frontend/.cursor/rules/state-management.mdc`
- `hms-frontend/.cursor/rules/features-domain.mdc`
- `hms-frontend/.cursor/rules/services-integration.mdc`
- `hms-frontend/.cursor/rules/hooks-utils.mdc`
- `hms-frontend/.cursor/rules/offline-sync.mdc`
- `hms-frontend/.cursor/rules/security.mdc`
- `hms-frontend/.cursor/rules/i18n.mdc`
- `hms-frontend/.cursor/rules/accessibility.mdc`
- `hms-frontend/.cursor/rules/performance.mdc`
- `hms-frontend/.cursor/rules/errors-logging.mdc`
- `hms-frontend/.cursor/rules/debug.mdc`
- `hms-frontend/.cursor/rules/bootstrap-config.mdc`
- `hms-frontend/.cursor/rules/coding-conventions.mdc`
- `hms-frontend/.cursor/rules/testing.mdc`

Conflict resolution order:
- Follow each rule file's declared single source of truth.
- If still unclear, prioritize: `index.mdc` references -> specific single-source files -> phase plan.

---

## Step Selection Contract (Mandatory)

- The request can target one or more step IDs from `0.1 to 0.21`.
- If specific step IDs are selected, implement only those selected IDs after confirming all earlier step IDs in this phase are already complete; if not, complete missing earlier steps first (no chronology skips).
- If selected steps need minimal shared prerequisite wiring, implement only the minimum prerequisite changes required.
- Do NOT auto-implement unselected sibling steps unless an earlier unselected step is required to satisfy mandatory chronology/prerequisite gates.
- Apply strict gate execution from `P000_setup.md`: complete each selected step fully (implementation + tests + compliance checks) before moving to the next selected step.

---

## Scope

- Complete selected setup and tooling bootstrap steps exactly as defined in Phase 0.
- Keep dependency installation, project structure, and configuration changes minimal to selected scope.
- Ensure scripts and config files are reproducible for all target platforms.

Primary areas for this phase:
- `package.json` and lockfile updates required by selected dependency steps
- Root tooling/config files (`babel.config.js`, `metro.config.js`, lint/prettier configs, jest config, `.gitignore`)
- Project folder/bootstrap structure and `scripts/debug/**` paths required by selected step(s)

---

## Implementation Rules (Mandatory)

### Architecture and Boundaries
- Keep layer boundaries from `project-structure.mdc` and `core-principles.mdc`.
- Reuse existing modules/hooks/utilities before creating new abstractions.
- Keep code JavaScript-only (`.js`/`.jsx`) per `coding-conventions.mdc`.
- Follow alias/import/export conventions exactly.

### Styling, UX, and Accessibility
- UI files must use i18n keys for all user-facing copy.
- Enforce accessibility semantics, focus handling, and touch target requirements.
- Use theme tokens only; avoid hardcoded design values.

### Data, Security, and Reliability
- When APIs are involved, use only mounted backend routes and valid DTO/enum shapes.
- Handle loading, empty, error, success, and offline states where applicable.
- Avoid ad-hoc `console.*` and sensitive data exposure in logs/UI.
- Prevent duplicate submissions and race-condition regressions.

### Testing and Verification
- Add/update tests for all changed behavior and required edge paths.
- Respect coverage requirements defined by phase plan and `testing.mdc`.
- Run targeted tests/checks for selected step(s) and report results.

---

## Phase Constraints (Mandatory)

- Do NOT implement runtime feature/business flows in Phase 0.
- Do NOT add dependencies that are not explicitly required by selected Phase 0 step(s).
- Do NOT restructure app architecture beyond selected setup/bootstrap steps.

---

## Step Gate Checklist (Mandatory per selected step)

1. Implement/fix only the selected step module/files with compliant structure.
2. Enforce i18n, accessibility, and token/rule compliance.
3. Add/update tests for the selected step behavior and edge cases.
4. Run relevant checks/tests and confirm pass/fail status.
5. Verify no architecture boundary violations.
6. Verify no unselected-step scope creep.

---

## Acceptance Criteria

- 100% compliance with all files in `hms-frontend/.cursor/rules/*`.
- Selected step(s) from `hms-frontend/dev-plan/P000_setup.md` are complete and production-ready.
- Backend integration (if applicable) matches mounted routes and contracts.
- `hms-frontend/write-up.md` alignment is preserved for selected scope.
- Tests and verification gates are satisfied for selected scope.
- No out-of-scope phase/step work was introduced.

---

## Deliverables

Return ONLY:

1. Implementation files changed for selected Phase 000 step(s).
2. Related export/config/wiring updates required by selected step(s) only.
3. i18n locale key updates required by selected step(s).
4. Tests/verification artifacts for selected step(s), including commands run and result summary.
5. A concise compliance report confirming:
   - selected step IDs implemented
   - rule compliance checks performed
   - backend/write-up alignment checks performed
   - any intentionally deferred work (must be out-of-scope and justified)

Do NOT include files or logic outside selected Phase 000 step(s).
